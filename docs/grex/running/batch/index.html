<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Batch jobs"><meta property="og:title" content="Batch jobs"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://um-grex.github.io/grex-docs/docs/grex/running/batch/"><title>Batch jobs | Unofficial Grex User Guide</title><link rel=icon href=/grex-docs/favicon.png type=image/x-icon><link rel=stylesheet href=/grex-docs/book.min.06cbd313f49ddc884804421299d5dc11b1cd097fdcfed7f054a79a137890a2d7.css integrity="sha256-BsvTE/Sd3IhIBEISmdXcEbHNCX/c/tfwVKeaE3iQotc="><script defer src=/grex-docs/en.search.min.c95a2a6673b8ae2b91e973b25314a9009fd41955e0c35a621d268359dcd2aa9f.js integrity="sha256-yVoqZnO4riuR6XOyUxSpAJ/UGVXgw1piHSaDWdzSqp8="></script><link rel=alternate type=application/rss+xml href=http://um-grex.github.io/grex-docs/docs/grex/running/batch/index.xml title="Unofficial Grex User Guide"></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><style>hr{border:0;height:3px;background-image:linear-gradient(to right,transparent,#095484,transparent)}</style><h2 class=book-brand><a href=http://um-grex.github.io/grex-docs><img src=/grex-docs/logo/um_logo_email_signature.png style=width:auto;height:auto alt=Logo><br><hr><span>Unofficial Grex User Guide</span><hr></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><hr><ul><li class=book-section-flat><a href=/grex-docs/docs/longread/>Notes of Grex Changes</a><ul><li class=book-section-flat><a href=/grex-docs/docs/longread/training/>Training Materials and Presentations</a><ul></ul></li></ul></li><li class=book-section-flat><a href=/grex-docs/docs/computecanada/>Accessing Compute Canada resources</a><ul></ul></li><li class=book-section-flat><a href=/grex-docs/docs/grex/>Grex HPC QuickStart</a><ul><li><a href=/grex-docs/docs/grex/access/>Access and Usage conditions</a></li><li><a href=/grex-docs/docs/grex/connecting/>Connecting / Transferring data</a></li><li><a href=/grex-docs/docs/grex/data/>Storage and Data</a></li><li><a href=/grex-docs/docs/grex/running/>Running Jobs</a><ul><li><a href=/grex-docs/docs/grex/running/batch/ class=active>Batch jobs</a><ul></ul></li><li><a href=/grex-docs/docs/grex/running/interactive/>Interactive work</a></li><li><a href=/grex-docs/docs/grex/running/contributed-systems/>Contributed systems</a></li></ul></li><li><a href=/grex-docs/docs/grex/ood/>Grex's OpenOnDemand Web Portal</a></li><li><a href=/grex-docs/docs/grex/software/>Software</a></li></ul></li><li><a href=/grex-docs/docs/faq/>Frequently Asked Questions</a></li><li><a href=/grex-docs/docs/localit/>Local IT Resources</a></li><li><a href=/grex-docs/docs/support-contacts/>Support and Training</a></li><li><a href=/grex-docs/docs/disclaimer/>Disclaimer</a></li></ul></nav><script>(function(){var a=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></aside><div class=book-page><article class=markdown><h1 id=batch-jobs>Batch jobs</h1><p>HPC systems usually are &ldquo;clusters&rdquo; of many compute nodes, which are joined by an interconnect, and under control of a resource management software. From the users' point of view, the HPC system is a unity, a single large machine rather than a network of individual computers. Most of the time, HPC systems are used in batch mode: users would submit so called &ldquo;jobs&rdquo; to a &ldquo;batch queue&rdquo;. A subset of the available resources of the HPC machine is allocated to each of the users batch jobs, and they run without any need for user intervention as soon as the resources become available.</p><p>The job placement, usage monitoring and job accounting are done via a special software, the HPC scheduler. This is an often under-appreciated automation that makes usage efficient and saves a lot of work on part of the user. However, using HPC is hard in a sense that users have to make effort in order to figure out what are the available resources on an HPC cluster, and what is the efficient way of requesting the resoures for their jobs. Asking for too many resources might be wasteful both in preventing others of using them and in making for a longer queuing time.</p><p>The resources (&ldquo;tractable resources&rdquo; in SLURM speak) are CPU time, memory, and GPU time. Generic resources can be software licenses, &mldr; etc. Requesting resources is done via command line options to job submission commands <strong>sbatch</strong> and <strong>salloc</strong>, or via special comment lines (starting with #SBATCH) in job scripts. There are also options to control job placement such as partitions.</p><p>There are default values for the resources which are taken when you do not specify the resource limit. Note that the default values are, as a rule, quite small. On Grex, the default values are set as follow: <strong>3 hours</strong> of walltime, <strong>256mb</strong> of memory per CPU. In most of the cases, it is better to have an explicit request of an appropriate resource limit rather than using the default.</p><p>We ask our users to be fair and considerate and do not allow for deliberate waste of resources (such as running serial jobs on more than one CPU core, or running CPU-only calculations on GPU nodes).</p><p>There are certain scheduling policies in place to prevent the cluster from being swamped by a single user. In particular, the MAXPS / GrpRunMins limit disfavours asking for many CPU cores for long walltimes, a MaxCPU limits restricts number of CPU cores used, and there are limits on number of user&rsquo;s jobs in the system and number of array job elements, as described below.</p><h2 id=batch-job-policies>Batch job policies</h2><p>The following policies are implemented on Grex:</p><blockquote class="book-hint info"><ul><li>The default walltime is 3 hours (equivalent to: <strong>--time=3:00:00</strong>).</li><li>The default amount of memory per processor (<strong>--mem-per-cpu=</strong>) is 256 mb. Memory limits are enforced, so an accurate estimate of memory resource (either in form of <strong>--mem=</strong> or <strong>--mem-per-cpu=</strong>) should be provided.</li><li>The maximum walltime is 21 days on <strong>compute</strong> and <strong>skylake</strong> partitions, 14 days on <strong>largemem</strong> partition.</li><li>The maximum number of processor-minutes for all currently running jobs of a group without a RAC is 4 M.</li><li>The maximum number of jobs that a user may have queued to run is 4000. The maximum size of an array job is 2000.</li><li>Users without a RAC award are allowed to simultaneously use up to 400 CPU cores per accounting group.</li><li>There are limits on number of GPUs that can be used on contributed hardware (1 GPU per job).</li></ul></blockquote><p>Note that you can see some information about the partitions by running the custom script <strong>partition-list</strong> from your terminal:</p><blockquote class="book-hint info">partition-list</blockquote><h2 id=typical-batch-job-cases>Typical Batch job cases</h2><p>Any batch job is submitted with <strong>sbatch</strong> command. Batch jobs are usually shell (BASH, etc.) scripts wrapping around the invocation of a code. The comments on top of the script that start with <strong>#SBATCH</strong> are interpreted by the SLURM scheduler as options for resource requests:</p><blockquote class="book-hint info"><ul><li><strong>--ntasks=</strong> : specifies number of tasks (MPI processes) per job.</li><li><strong>--nodes=</strong> : specifies number of nodes (servers) per job.</li><li><strong>--ntasks-per-node=</strong> : specifies number of tasks (MPI processes) per node.</li><li><strong>--cpus-per-task=</strong> : specifies number of threads per task. This parameter should not exceed the number of physical cores per node.</li><li><strong>--mem-per-cpu=</strong> : specifies memory per task (or thread?).</li><li><strong>--mem=</strong> : specifies memory per node.</li><li><strong>--gpus=</strong> : specifies number of GPUs per job. There are also <em>--gpus-per-XXX</em> and <em>--XXX-per-gpu</em> resource specs.</li><li><strong>--time-</strong> : specifies walltime in format DD-HH:MM:SS</li><li><strong>--qos=</strong> : specifies a QOS by its name (Not to be used on Grex!).</li><li><strong>--partition=</strong> : specifies a partiton by its name (<strong>very much used on Grex!</strong>).</li></ul></blockquote><p>Assuming the name of <em>myfile.slurm</em> (the name or the extension does not matter, it can can be called <em>afile.job</em>, <em>otherjob.sh</em>, &mldr; etc.), a job is submitted with the command:</p><blockquote class="book-hint info"><code>sbatch myfile.slurm</code></blockquote><p>or</p><blockquote class="book-hint info"><code>sbatch [+ some options] myfile.slurm</code></blockquote><p>Some options like <strong>--partition=compute</strong> could be invoked at sumbmission time.</p><p>Refer to the official SLURM <a href=https://slurm.schedmd.com/documentation.html target=_blank rel=noopener>documentation</a>
and/or <strong>man sbatch</strong> for the available options. Below we provide examples for typical cases of SLURM jobs.</p><h2 id=serial-jobs>Serial Jobs</h2><p>The simplest kind of job is a serial job when one compute process runs in a sequential fashion. Naturally, such job can utilize only a single CPU core: even large parallel supercomputers as a rule do not parallelize binary codes automatically. So the CPU request for a serial job is always 1, which is the default; the other resources can be wall time and memory. SLURM has two ways of specifying the later: memory per cpu core (<strong>--mem-per-cpu=</strong>) and total memory per node (<strong>--mem=</strong>). It is more logical to use per-core memory always; except in case of the whole-node jobs when special value <strong>--mem=0</strong> gives all the available memory for the allocated node. An example script (for 1 CPU, wall time of 30 minutes and a memory of 2500M) is provided below.</p><blockquote class="book-hint slurm"><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:teal>#!/bin/bash
</span><span style=color:teal></span><span style=color:#080;font-style:italic>#SBATCH --time=0-0:30:00</span>
<span style=color:#080;font-style:italic>#SBATCH --mem=2500M</span>
<span style=color:#080;font-style:italic>#SBATCH --job-name=&#34;Serial-Job-Test&#34;</span>
<span style=color:#080;font-style:italic># Script for running serial program: your_program</span>
echo <span style=color:#00f>&#34;Current working directory is `pwd`&#34;</span>
<span style=color:#080;font-style:italic># Load modules if needed:</span>
echo <span style=color:#00f>&#34;Starting run at: `date`&#34;</span>
./your_program &lt;+options or arguments <span style=color:navy;font-weight:700>if</span> any&gt;
echo <span style=color:#00f>&#34;Job finished with exit code </span>$?<span style=color:#00f> at: `date`&#34;</span></code></pre></div></blockquote><p>An important special case of serial jobs is high-throughput computing: jobs are serial because they are too short to parallelize them, however there are very many such jobs per research project. The case of embarassingly parallel computations like some of the Monte Carlo simulations are often High Throughput Computing (HTC).</p><blockquote class="book-hint info"><ul><li>Serial jobs that have regularely named inputs and run more than a few minutes each best be specified as Array Jobs (see below).</li><li>Serial jobs that are great in numbers, and run less than a few minutes each, better be joined into a task farm running within a single larger job using tools like GLOST, GNU Parallel or a workflow engine like QDO.</li></ul></blockquote><p>An example of GLOST job is under MPI jobs section (see below).</p><h2 id=smp--threaded--single-node-jobs>SMP / threaded / single node jobs</h2><p>A next kind of job is multi-threaded, shared memory or or single-node parallel jobs. Often these jobs are for Symmetric Multiprocessing (SMP) codes that can use more than one CPU on a given node to speed up the calculations. However, SMP/multithreaded jobs rely on some form of inter-process communication (shared memory, &mldr; etc.) that limits them to the CPU cores within just a single server. They cannot scale across multiple compute nodes. Examples are OpenMP, pthreads, Java codes, etc. Gaussian and PSI4 are SMP codes; threaded BLAS/LAPACK routines from MKL (inside NumPY) can utilize multiple threads, &mldr; etc. Note that this kind of programs do not scle very well when increasing the number of threads. We recommend to our users to run a benchmark to see how your programs <a href=https://docs.computecanada.ca/wiki/Scalability/en target=_blank rel=noopener>scale with number of threads</a>
to define the combination or a set of threads for better performance.</p><p>Thus, from the point of view of the SMP/threaded jobs resources request, the following considerations are important:</p><blockquote class="book-hint info"><ul><li>asking always only a single compute node (<strong>--nodes=1 --ntasks=1</strong>) node</li><li>asking for several CPU cores on it per job, up to the maximum number of CPU cores per node (<strong>--cpus-per-task=N</strong>) where N should not exceed the total physical cores available on the node. Depending on the partition, you may choose N up to 12 <strong>compute</strong>, up to 52 on <strong>skylake</strong>, up to 40 on <strong>largemem</strong>, &mldr; etc.</li><li>making sure that the total memory asked for do not exceed the memory available on the node.</li><li>making sure that the code would use exactly the number of CPU cores allocated to the job, to prevent waste or congestion of the resources.</li></ul></blockquote><p>In SLURM, it makes a difference whether you ask for &lsquo;parallel tasks (--ntasks)&rsquo; or &lsquo;threads (--cpus-per-task)&rsquo; ; the threads should not be isolated from each other (because they might need to use shared memory!) but the tasks are isolated to each own &ldquo;cgroup&rdquo;.</p><p>An enviromental variable <strong>${SLURM_CPUS_PER_TASK}</strong> is set in the job, so you can set an appropriate parameter of your code to the same value.</p><p>For OpenMP, it would be done like:</p><blockquote class="book-hint info"><code>export OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK}</code></blockquote><p>For MKL it is <em>MKL_NUM_THREADS</em>, for Julia -- JULIA_NUM_THREADS, for Java -Xfixme parameter.</p><blockquote class="book-hint slurm"><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:teal>#!/bin/bash
</span><span style=color:teal></span><span style=color:#080;font-style:italic>#SBATCH --time=0-8:00:00</span>
<span style=color:#080;font-style:italic>#SBATCH --nodes=1</span>
<span style=color:#080;font-style:italic>#SBATCH --ntask-per-node=1</span>
<span style=color:#080;font-style:italic>#SBATCH --cpus-per-task=12</span>
<span style=color:#080;font-style:italic>#SBATCH --mem=0</span>
<span style=color:#080;font-style:italic>#SBATCH --partition=compute</span>
<span style=color:#080;font-style:italic>#SBATCH --job-name=&#34;OMP-Job-Test&#34;</span>
<span style=color:#080;font-style:italic># An example of an OpenMP threaded job that takes a whole &#34;old&#34; Grex node for 8 hours. </span>
export OMP_NUM_THREADS=<span style=color:#00f>${</span>SLURM_CPUS_PER_TASK<span style=color:#00f>}</span>
echo <span style=color:#00f>&#34;Starting run at: `date`&#34;</span>
./your-openmp.x input.dat &gt; output.log <span style=color:#080;font-style:italic># OpenMP codes are usually homegrown.</span>
echo <span style=color:#00f>&#34;Job finished with exit code </span>$?<span style=color:#00f> at: `date`&#34;</span></code></pre></div></blockquote><p>Note that the above example request whole node&rsquo;s memory with <strong>--mem=0</strong> because the node is allocated to the job fully due to all the CPUs anyways. It is easier to use the <strong>--mem</strong> syntax for SMP jobs because typically the memory is shared between threads (i.e., the amount of memory used does not change with the number of SMP threads). Note, however, that the memory request should be reasonably &ldquo;efficient&rdquo; if possible.</p><h2 id=gpu-jobs>GPU jobs</h2><p>The GPU jobs would usually be similar to SMP/threaded jobs, with the following differences:</p><blockquote class="book-hint info"><ul><li><p>The GPU jobs should run on the nodes that have GPU hardware, which means you&rsquo;d want always to specify <strong>--partition=gpu</strong> or <strong>--partition=stamps-b</strong> or <strong>livi-b</strong>.</p></li><li><p>SLURM on Grex uses so called &ldquo;GTRES&rdquo; plugin for scheduling GPU jobs, which means that the request syntax in the form <strong>--gpus=N</strong> or <strong>--gpus-per-node=N</strong> or <strong>--gpus-per-task=N</strong> is used.</p></li></ul></blockquote><p><em>How many GPUs to ask for?</em></p><p>Grex, at the moment, does not have GPU-direct MPI enabled, which means that most of the jobs would be single-node. The GPU nodes in either <strong>gpu</strong> (two nodes there, 32GB V100s) or <strong>stamps-b</strong> (three nodes, 16GB V100s) partition have 4 V100 GPUs, 32 Intel 52xx CPUs and 192GB of CPU memory. (There also is the <strong>livi-b</strong> partition with a large single 16x v100 GPU server, but it seldom has all 16GPUs idle). So, asking 1 to 4 GPUs, one node, and 6-8 CPUs per GPU with an appropriate amount of RAM (4-8GB) per job would be a good starting point.</p><p>Note that V100 is a fairly large GPU for most of the jobs, and for good utilization of the GPU resources available on Grex, it is a good idea to start with single GPU, and then try if the code actually is able to saturate it with load. Many codes cannot scale to utilize more than one GPU, and few codes can utilize more than two of them.</p><blockquote class="book-hint slurm"><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:teal>#!/bin/bash
</span><span style=color:teal></span><span style=color:#080;font-style:italic>#SBATCH --ntasks=1 --cpus-per-task=6</span>
<span style=color:#080;font-style:italic>#SBATCH --time=0-12:00:00 --mem-per-cpu=6000M</span>
<span style=color:#080;font-style:italic>#SBATCH --job-name=genomics-test</span>
<span style=color:#080;font-style:italic>#SBATCH --gpus=1 --partition=stamps-b</span>
<span style=color:#080;font-style:italic># adjust the resource requests above to your needs.</span>
<span style=color:#080;font-style:italic># Example of loading modules, CUDA:</span>
module load gcc/4.8 cuda/10.2
export OMP_NUM_THREADS=<span style=color:#00f>${</span>SLURM_CPUS_PER_TASK<span style=color:#00f>}</span>
echo <span style=color:#00f>&#34;Starting run at: `date`&#34;</span>
nvidia-smi
guppy_basecaller -x auto --gpu_runners_per_device <span style=color:#00f>6</span> -i Fast5 -s GuppyFast5 -c dna_r9.4.1_450bps_hac.cfg
echo <span style=color:#00f>&#34;Job finished with exit code </span>$?<span style=color:#00f> at: `date`&#34;</span></code></pre></div></blockquote><p>The above script (if called say, gpu.job) can be submitted with the usual command:</p><blockquote class="book-hint info"><code>sbatch gpu.job</code></blockquote><h2 id=distributed-massively-parallel-jobs>Distributed, massively parallel jobs</h2><p>Parallel jobs that can spawn multiple servers are the most scalable ones, because they are not limited by the number of CPUs or memory per node. Running many parallel tasks across more than one node requires some inter-node communication (which as a rule is slower than shared memory within one server). In HPC, high speed interconnect and specialized RDMA-aware communication libraries make distributed parallel computational very scalable. Grex uses Infiniband interconnect.</p><p>Most often (but not always), parallel programs are built upon a low-level message passing library called MPI. Refer to the Software section for the informations of the parallel libraries on Grex. Examples of distributed parallel codes are GAMESS-US, <a href=/grex-docs/docs/grex/software/specific/orca/>ORCA</a>
, <a href=/grex-docs/docs/grex/software/specific/lammps/>LAMMPS</a>
, <a href=/grex-docs/docs/grex/software/specific/vasp/>VASP</a>
, &mldr; etc.</p><p>The distributed parallel jobs can be placed across their compute nodes in several ways (i.e., how many parallel tasks per compute node?). Thus SLURM resource request syntax alows to specify the required layout of nodes/tasks (or nodes/tasks/threads, or even nodes/tasks/GPUs since hybrid MPI+OpenMP and MPI+GPU programs exist). A consideration about the layout is a tradeoff between making program to work faster (and sometimes to work correctly at all) and making the scheduler&rsquo;s work easier.</p><p>A well written MPI software theoretically should not care how the tasks are distributed across how many physical compute nodes. Thus, SLURM&rsquo;s <strong>--ntasks=</strong> request (similar to the old Torque <strong>procs=</strong>) specified without <strong>--nodes</strong> would work and make the scheduling easier.</p><p><strong>A note on process starting:</strong></p><p>Since MPI jobs are distributed, there should be a mechanism to start the compute processes across all of the nodes (or CPUs) allocated for it. The mechanism should know which nodes to use, and how many. Most modern MPI implementations &ldquo;tightly integrate&rdquo; with SLURM, so they will get this informaton automatically via a Process Management Interface (PMI). SLURM provides its own job starting command called <strong><a href=https://slurm.schedmd.com/srun.html target=_blank rel=noopener>srun</a>
</strong>. Most MPI implementations also provide their own job spawner commands, usually called <strong>mpiexec</strong> or <strong>mpirun</strong> . These are specific to each MPI vendor/kind and not well standartised, and differ in the support of SLURM.</p><p>For example, OpenMPI (the default, supported MPI implementation) on Grex is compiled against PMIx (3.x, 4.x) or PMI1 (1.6.5). So it is preferrable to use <strong>srun</strong> instead of <strong>mpiexec</strong> to kickstart the MPI proecesses, because <strong>srun</strong> would use PMI.</p><p>For Intel MPI (another MPI, also available on Grex and required by some of the binary codes, like ANSYS or ADF), <strong>srun</strong> sometimes may not work, but PMI1 can be used with <strong>mpiexec.hydra</strong> by setting the following environmemt variable:</p><blockquote class="book-hint info"><code>export I_PMI_LIBRARY=/opt/slurm/lib/libpmi.so</code></blockquote><blockquote class="book-hint slurm"><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:teal>#!/bin/bash
</span><span style=color:teal></span><span style=color:#080;font-style:italic>#SBATCH --time=0-8:00:00</span>
<span style=color:#080;font-style:italic>#SBATCH --mem-per-cpu=2500M</span>
<span style=color:#080;font-style:italic>#SBATCH --ntasks=32</span>
<span style=color:#080;font-style:italic>#SBATCH --job-name=&#34;Espresso-Job&#34;</span>
<span style=color:#080;font-style:italic># A example of an MPI parallel that takes 32 cores on Grex for 8 hours. </span>
<span style=color:#080;font-style:italic># Load the modules:</span>
module load intel/15.0.5.223 ompi/3.1.4 espresso/6.3.1
echo <span style=color:#00f>&#34;Starting run at: `date`&#34;</span>
srun pw.x -in MyFile.scf.in  &gt; Myfile.scf.log 
echo <span style=color:#00f>&#34;Job finished with exit code </span>$?<span style=color:#00f> at: `date`&#34;</span></code></pre></div></blockquote><p>However, in practice there are cases when layout should be more restrictive. If the software code assumes equal distribution of processes per node, the request should be <strong>--nodes=N --ntasks-per-node=M</strong>. A similar case is MPMD codes (Like <a href=/grex-docs/docs/grex/software/specific/nwchem/>NWCHem</a>
or GAMESS or OpenMolcas) that have some of the processes doing computation and some communication functions, and therefore requiring at least two tasks running per each node.</p><p>For some codes, especially for large parallel jobs with intensive communication between tasks there can be performance differences due to memory and interconnect bandwidths, depending on whether the same number of parallel tasks is compacted on few nodes or spread across many of them. Find an example of the job below.</p><blockquote class="book-hint slurm"><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:teal>#!/bin/bash
</span><span style=color:teal></span><span style=color:#080;font-style:italic>#SBATCH --time=0-8:00:00</span>
<span style=color:#080;font-style:italic>#SBATCH --mem-per-cpu=4000M</span>
<span style=color:#080;font-style:italic>#SBATCH --ntasks-per-node=8 --nodes=4</span>
<span style=color:#080;font-style:italic>#SBATCH --job-name=&#34;NWchem-Job&#34;</span>
<span style=color:#080;font-style:italic># An example of an MPI parallel that takes 32 cores </span>
<span style=color:#080;font-style:italic># across 4 grex Grex nodes for 8 hours. </span>
module load intel/15.0.5.223 ompi/3.1.4 nwchem/6.8.1
<span style=color:#080;font-style:italic># Uncomment/Change these in case you want to use custom basis sets</span>
NWCHEMROOT=/global/software/cent7/nwchem/6.8.1-intel15-ompi314
export NWCHEM_NWPW_LIBRARY=<span style=color:#00f>${</span>NWCHEMROOT<span style=color:#00f>}</span>/data/libraryps
export NWCHEM_BASIS_LIBRARY={NWCHEMROOT}/data/libraries
<span style=color:#080;font-style:italic># In most cases SCRATCH_DIR would  be on local nodes scratch</span>
<span style=color:#080;font-style:italic># While results are in the same directory</span>
export NWCHEM_SCRATCH_DIR=$TMPDIR
export NWCHEM_PERMANENT_DIR=<span style=color:#00f>`</span>pwd<span style=color:#00f>`</span>
<span style=color:#080;font-style:italic># Optional memory setting; note that this one or the one in your code</span>
<span style=color:#080;font-style:italic># must match the #SBATCH -l mem= value !</span>
export NWCHEM_MEMORY_TOTAL=<span style=color:#00f>1000000000</span> <span style=color:#080;font-style:italic># 12000 MB, double precision words only</span>
export MKL_NUM_THREADS=<span style=color:#00f>1</span>
echo <span style=color:#00f>&#34;Starting run at: `date`&#34;</span>
srun nwchem dft_feco5.nw &gt; dft_feco5.$SLURM_JOBID.log
echo <span style=color:#00f>&#34;Job finished with exit code </span>$?<span style=color:#00f> at: `date`&#34;</span></code></pre></div></blockquote><h3 id=openmpi>OpenMPI</h3><p>OpenMPI is the default MPI implementation for Grex (and ComputeCanada). The modules for it on Grex are called <strong>ompi</strong> . The MPI example scripts above are all OpenMPI based. The old version 1.6.5 is there for compatibility reasons with older software; most users should use 3.1.x or 4.x.x versions. Using <strong>srun</strong> is recommended in all cases.</p><h3 id=intel-mpi>Intel MPI</h3><p>For applications using IntelMPI (<strong>impi</strong> modules on Grex, or Intel-MPI based software from Compute Canada CVMFS software stack), a few environment variables have to be set. The following link explains it: <a href=https://software.intel.com/en-us/articles/how-to-use-slurm-pmi-with-the-intel-mpi-library-for-linux target=_blank rel=noopener>Using SLURM with PMI</a>
.</p><p>The JLab documentation example shows an <a href=https://scicomp.jlab.org/docs/intelMPIJobs target=_blank rel=noopener>example of SLURM script with IntelMPI</a>
.</p><h3 id=other-mpis>Other MPIs</h3><p>Finally, some canned codes like ANSYS or StatCCM+ would use a vendor-specific MPI implementation that would not tightly integrate with our scheduler&rsquo;s process to CPU core placement. In that case, several whole nodes (that is, with number of tasks equal to the node&rsquo;s number of CPU cores) should be requested to prevent the impact on other jobs with resource congestion.</p><p>Such codes will also require a nodelist (machinefile) file obtained from SLURM and provided to them in their own format.</p><p>Compute Canada&rsquo;s <strong>slurm_hl2hl.py</strong> script makes this easier (see <a href=https://docs.computecanada.ca/wiki/Star-CCM%2B target=_blank rel=noopener>CC StarCCM+</a>
or <a href=https://docs.computecanada.ca/wiki/ANSYS#Cluster_Batch_Job_Submission target=_blank rel=noopener>CC ANSYS documentation</a>
). The script <strong>slurm_hl2hl.py</strong> is already available on Grex.</p><blockquote class="book-hint info"><code>slurm_hl2hl.py --format STAR-CCM+ > machinefile</code></blockquote><h2 id=array-jobs>Array jobs</h2><p>Array jobs allow for submitting many similar jobs &ldquo;in one blow&rdquo;. It saves users work on job sumbission, and also makes SLURM scheduler more efficient in scheduling the array jobs because it would know they are the same with respect to size, expected walltime etc.</p><p>Array jobs work most naturally when a single code has to be applied for paramter sweep and/or to a large number of input files that are reguraly named, for example as: test1.in, test2.in, &mldr; test99.in</p><p>Then, a single job script with <strong>#SBATCH --array=1,99</strong> can be used to submit the 99 jobs.</p><p>In order to distinguish between the input files, within each of the jobs at run time, you would have to obtain a value for the array index. Which is set by SLURM as <strong>${SLURM_ARRAY_TASK_ID}</strong> environment variable. The call to the code on a particular input will then be like:</p><blockquote class="book-hint info"><code>./my_code test${SLURM_ARRAY_TASK_ID}.in</code></blockquote><p>This way each of the array element jobs can distinguish their own portion of the work to do. A real life example is below; it attempts to run all of the <a href=/grex-docs/docs/grex/software/specific/gaussian/>Gaussian</a>
standard tests which have names of the format test0001.com, test0002.com, .. test1204.com, etc. Note the <strong>printf</strong> trick to deal with trailing zeroes in the input names.</p><blockquote class="book-hint slurm"><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:teal>#!/bin/bash
</span><span style=color:teal></span><span style=color:#080;font-style:italic>#SBATCH --cpus-per-task=1</span>
<span style=color:#080;font-style:italic>#SBATCH --mem=1000MB</span>
<span style=color:#080;font-style:italic>#SBATCH --job-name=&#34;G16-tests&#34;</span>
<span style=color:#080;font-style:italic>#SBATCH --array=1-1204</span>
echo <span style=color:#00f>&#34;Current working directory is `pwd`&#34;</span>
echo <span style=color:#00f>&#34;Running on `hostname`&#34;</span>
echo <span style=color:#00f>&#34;Starting run at: `date`&#34;</span>
<span style=color:#080;font-style:italic># Set up the Gaussian environment using the module command:</span>
module load gaussian/g16.c01
<span style=color:#080;font-style:italic># Run g16 on an array job element</span>
id=<span style=color:#00f>`</span>printf <span style=color:#00f>&#34;%04d&#34;</span> $SLURM_ARRAY_TASK_ID<span style=color:#00f>`</span>
v=test<span style=color:#00f>${</span>id<span style=color:#00f>}</span>.com
w=<span style=color:#00f>`</span>basename $v .com<span style=color:#00f>`</span>
g16 &lt; $v &gt; <span style=color:#00f>${</span>w<span style=color:#00f>}</span>.<span style=color:#00f>${</span>SLURM_JOBID<span style=color:#00f>}</span>.out
echo <span style=color:#00f>&#34;Job finished with exit code </span>$?<span style=color:#00f> at: `date`&#34;</span></code></pre></div></blockquote><p>There are limits on how large array jobs can be (see our scheduling policies): the maximal number of elements in job array, as well as the maximal number of jobs that can be submitted by a user.</p><h2 id=using-cc-cvmfs-software>Using CC CVMFS software</h2><p>As explained in more detail in the software/Modules documentation, we provide Compute Canada&rsquo;s software environment. Most of it can run out of the box by just specifying corresponding module.</p><p>There are some <strong>caveats</strong>:</p><blockquote class="book-hint info"><ul><li><p>Some of the Compute Canada software might have hardcoded environmental variables that exists only on these systems. An example being <strong>SLURM_TMPDIR</strong>. On Grex, add <strong>export SLURM_TMPDIR=$TMPDIR</strong> to your job scripts.</p></li><li><p>In general, it is hard to containerize HPC. So the software that requires low-lewel hardware/device drivers access (OpenMPI, CUDA) may have problems when running on non-CC systems. Newer version of OpenMPI (3.1.x) seems to be more portable for using the PMIx job starting mechanism.</p></li><li><p>&ldquo;Restricted&rdquo; (commercial) software&rsquo;s binaries are not distributed by Compute Canada CVMFS due to the obvious licensing issues. It has to be installed locally on Grex.</p></li></ul></blockquote><p>Having said that, <strong>module load CCEnv</strong> gives the right software environment to be run on Grex for a vast majority of threaded and serial software items from CC softvare stack. See discussion about MPI-parallel jobs below.</p><p>Because of the distributed nature of CVMFS, it might take time to download a program or library or data file. It would probably make sense to first access it interactively or from an interactive job to warm the CVMFS local cache, to avoid job failures due to the delay.</p><p>Below is an example of an R serial job that uses quite a few packages from Compute Canada software stack.</p><blockquote class="book-hint slurm"><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:teal>#!/bin/bash
</span><span style=color:teal></span><span style=color:#080;font-style:italic>#SBATCH --ntasks=1</span>
<span style=color:#080;font-style:italic>#SBATCH --mem-per-cpu=4000M</span>
<span style=color:#080;font-style:italic>#SBATCH --time=0-72:00:00</span>
<span style=color:#080;font-style:italic>#SBATCH --job-name=&#34;R-gdal-jags-bench&#34;</span>
cd <span style=color:#00f>${</span>SLURM_SUBMIT_DIR<span style=color:#00f>}</span>
<span style=color:#080;font-style:italic># Load the modules:           </span>
module load CCEnv
module load nixpkgs/16.09 gcc/5.4.0
module load r/3.5.2 jags/4.3.0 geos/3.6.1 gdal/2.2.1
export MKL_NUM_THREADS=<span style=color:#00f>1</span> 
echo <span style=color:#00f>&#34;Starting run at: `date`&#34;</span>
R --vanilla &lt; Benchmark.R &amp;&gt; benchmark.<span style=color:#00f>${</span>SLURM_JOBID<span style=color:#00f>}</span>.txt
echo <span style=color:#00f>&#34;Program finished with exit code </span>$?<span style=color:#00f> at: `date`&#34;</span></code></pre></div></blockquote><p>Users of contributed systems which are newer than the original Grex nodes might want to switch to <strong>arch/avx2</strong> or <strong>arch/avx512</strong> from the default <strong>arch/sse3</strong>.</p><h3 id=using-cc-cvmfs-software-that-is-mpi-based>Using CC CVMFS software that is MPI-based.</h3><p>We have found that the recent Compute Canada toolchains that use OpenMPI 3.1.x work on Grex without any changes (that is, with <strong>srun</strong>). Therefore for OpenMPI based applications, we recommend to load Compute Canada&rsquo;s software that depends on the recent toolchains, 2018.3 or later (Intel 2018 compilers, GCC 7.3 compilers and openmpi/3.1.2).</p><p>For example, the module commands below would load the Intel/OpenMPI 3.1.2 toochain-based environment:</p><blockquote class="book-hint info"><p><code>module load CCEnv</code></p><p><code>module load StdEnv/2018.3</code></p></blockquote><p>Below is an arbitrarily chosen IMB benchmark result for MPI1 on Grex, the <em>sendrecv</em> tests using two processes on two nodes with several MPI implementations (CC means MPI coming from the ComputeCanada stack, Grex means compiled locally on Grex).</p><p><p class=md__image><img src=/doc/mpis-on-grex.png alt style="border:1px solid #000"></p></p><p>You can see that differences in performance between OpenMPI 3.1.x from CC stack and Grex are minor for this benchmark, even vithout attemting at any local tuning for the CC OpenMPI.</p><h3 id=using-new-2020-cc-cvmfs-stack>Using New 2020 CC CVMFS Stack</h3><p>Since Spring 2021, Compute Canada had updated the default software stack on ther CVMFS distribution to StdEnv/2020 and gentoo. This version will not run on legacy Grex partitions (<strong>compute</strong>) at all, because it requires AVX2 CPU architecture. It will work as expected on all new GPU and CPU nodes (<strong>skylake</strong>, <strong>largemem</strong>, <strong>gpu</strong> and contributed systems).</p></article><div class="book-footer justify-between"><div><a class="flex align-center" href=https://github.com/um-grex/grex-docs/commit/4a07d74120d95d4386c1c274f941df41cb1cc57e title="Last modified by Shamov | Feb 16, 2022" target=_blank><img src=/grex-docs/svg/calendar.svg class=book-icon alt=Calendar>
<span>Feb 16, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/um-grex/grex-docs/blob/master/content/docs/grex/running/batch/_index.md target=_blank><img src=/grex-docs/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><br><hr></div><aside class="book-toc levels-4 fixed"><nav id=TableOfContents><ul><li><a href=#batch-jobs>Batch jobs</a><ul><li><a href=#batch-job-policies>Batch job policies</a></li><li><a href=#typical-batch-job-cases>Typical Batch job cases</a></li><li><a href=#serial-jobs>Serial Jobs</a></li><li><a href=#smp--threaded--single-node-jobs>SMP / threaded / single node jobs</a></li><li><a href=#gpu-jobs>GPU jobs</a></li><li><a href=#distributed-massively-parallel-jobs>Distributed, massively parallel jobs</a><ul><li><a href=#openmpi>OpenMPI</a></li><li><a href=#intel-mpi>Intel MPI</a></li><li><a href=#other-mpis>Other MPIs</a></li></ul></li><li><a href=#array-jobs>Array jobs</a></li><li><a href=#using-cc-cvmfs-software>Using CC CVMFS software</a><ul><li><a href=#using-cc-cvmfs-software-that-is-mpi-based>Using CC CVMFS software that is MPI-based.</a></li><li><a href=#using-new-2020-cc-cvmfs-stack>Using New 2020 CC CVMFS Stack</a></li></ul></li></ul></li></ul></nav></aside></main></body></html>